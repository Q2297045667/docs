---
title: 对话 API
description: 1.21.7 版本中引入的对话 API 指南。
slug: paper/dev/dialogs
version: 1.21.8
sidebar:
  badge:
    text: 实验性
    variant: danger
---

import Video from "/src/components/Video.astro";

import DialogShowcaseMp4 from "./assets/dialogs/dialog-showcase.mp4?url";
import InputDialogShowcaseMp4 from "./assets/dialogs/input-dialog-showcase.mp4?url";

:::danger[实验性]

对话 API 目前处于实验阶段，未来可能会发生变化。

:::

[对话](https://minecraft.wiki/w/Dialog ) 是在 Minecraft [1.21.6](https://minecraft.wiki/w/Java_Edition_1.21.6 ) 更新中新增的功能。
Paper 在 1.21.7 中发布了用于创建自定义对话的开发者 API。
本节旨在介绍此 API 以及您可以和不可以在对话中做的事情。

## 什么是对话？
对话框是服务器向客户端发送自定义游戏内菜单的一种方式。
它们可以用于显示各种信息，或者提供一种便捷的方式收集用户输入。

对话框可以在配置阶段或正常游戏过程中展示给玩家，这使得它们成为一种非常灵活的工具。
一个简单的对话框可能如下所示：

![在配置阶段发送的对话框](./assets/dialogs/confirmation-dialog.png)

此处展示的对话框是一个**确认**类型的对话框，
这意味着它总是包含两个按钮，一个用于确认，一个用于拒绝。

## 展示对话框
可以通过 `/dialog show <players> <dialog>` 命令在游戏中展示对话框。
或者，你也可以通过 API 使用 [Audience#showDialog(DialogLike)](https://jd.advntr.dev/api/latest/net/kyori/adventure/audience/Audience.html#showDialog(net.kyori.adventure.dialog.DialogLike)) 来展示它们。
你可以从 [`Dialog`](jd:paper:io.papermc.paper.dialog.Dialog) 接口中静态获取内置对话框。
新对话框可以使用 [`Dialog#create`](jd:paper:io.papermc.paper.dialog.Dialog#create(java.util.function.Consumer)) 动态创建，
或者如果在启动阶段注册，可以通过 `RegistryAccess.registryAccess().getRegistry(RegistryKey.DIALOG).get(Key)` 从对话框注册表中获取。

## 内置对话框
有三种内置对话框：
- [服务器链接](jd:paper:io.papermc.paper.registry.keys.DialogKeys#SERVER_LINKS)
- [快速操作](jd:paper:io.papermc.paper.registry.keys.DialogKeys#QUICK_ACTIONS)
- [自定义选项](jd:paper:io.papermc.paper.registry.keys.DialogKeys#CUSTOM_OPTIONS)

### 添加服务器链接
你可以通过从 [`Bukkit.getServer().getServerLinks()`](jd:paper:org.bukkit.Server#getServerLinks()) 获取 [`ServerLinks`](jd:paper:org.bukkit.ServerLinks) 实例，
并使用各种修改方法来添加服务器链接。
玩家可以通过打开游戏菜单（按下 `esc` 键）并点击 `服务器链接...` 按钮，随时打开服务器链接菜单。
此按钮仅在存在服务器链接时才会显示。

## 动态创建对话框
你可以使用 [`Dialog#create`](jd:paper:io.papermc.paper.dialog.Dialog#create(java.util.function.Consumer)) 方法构建一个 [`Dialog`](jd:paper:io.papermc.paper.dialog.Dialog) 对象。
Consumer 参数允许你构建对话框。
**对话框总是需要一个基础和一个类型**，这可以在构建器中声明。
你可以创建一个新的对话框，或者使用一个现有的[注册表注册的](#registering-dialogs-in-the-register)对话框作为基础。

作为参考，一个非常简单的（通知类型）对话框可以通过以下代码构建并展示给玩家：

<details>
  <summary>游戏内预览</summary>
  ![仅包含标题和确定按钮的对话框](./assets/dialogs/notice-dialog.png)
</details>

```java
Dialog dialog = Dialog.create(builder -> builder.empty()
    .base(DialogBase.builder(Component.text("Title")).build())
    .type(DialogType.notice())
);
player.showDialog(dialog);
```

### 对话框基础
你可以使用其[构建器](jd:paper:io.papermc.paper.registry.data.dialog.DialogBase$Builder)创建对话框基础，
该构建器可以通过 [`DialogBase.builder(Component title)`](jd:paper:io.papermc.paper.registry.data.dialog.DialogBase#builder(net.kyori.adventure.text.Component)) 创建。
对话框基础可以声明以下值：

| 构建器方法                                                                                                                                                                                    | 描述                |
|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------|
| [`afterAction(DialogAfterAction)`](jd:paper:io.papermc.paper.registry.data.dialog.DialogBase\$Builder#afterAction\(io.papermc.paper.registry.data.dialog.DialogBase.DialogAfterAction\)) | 对话框关闭后要执行的操作      |
| [`canCloseWithEscape(boolean)`](jd:paper:io.papermc.paper.registry.data.dialog.DialogBase\$Builder#canCloseWithEscape\(boolean\))                                                        | 是否可以通过`esc`键关闭对话框 |
| [`externalTitle(Component)`](jd:paper:io.papermc.paper.registry.data.dialog.DialogBase\$Builder#externalTitle\(net.kyori.adventure.text.Component\))                                     | 在打开此对话框的按钮上显示的标题  |
| [`body(List<? extends DialogBody>)`](jd:paper:io.papermc.paper.registry.data.dialog.DialogBase\$Builder#body\(java.util.List\))                                                          | 对话框的主体内容。         |
| [`inputs(List<? extends DialogInput>)`](jd:paper:io.papermc.paper.registry.data.dialog.DialogBase\$Builder#inputs\(java.util.List\))                                                     | 对话框的输入内容。         |

#### 对话框主体
对话框可以包含任意数量的主体组件。
可以通过 [`DialogBody.plainMessage(Component)`](jd:paper:io.papermc.paper.registry.data.dialog.body.DialogBody#plainMessage(net.kyori.adventure.text.Component)) 创建用于显示文本的主体条目，
或者通过 [`DialogBody.item(ItemStack)`](jd:paper:io.papermc.paper.registry.data.dialog.body.DialogBody#item(org.bukkit.inventory.ItemStack)) 创建用于显示物品的主体条目。

#### 对话框输入
有四种收集输入的方式：

- [`DialogInput.bool`](jd:paper:io.papermc.paper.registry.data.dialog.input.DialogInput#bool(java.lang.String,net.kyori.adventure.text.Component))

   一个简单的复选框，表示真或假的状态

   ![](./assets/dialogs/input-boolean.gif)

- [`DialogInput.singleOption`](jd:paper:io.papermc.paper.registry.data.dialog.input.DialogInput#singleOption(java.lang.String,net.kyori.adventure.text.Component,java.util.List))

   一个多项选择按钮

   ![](./assets/dialogs/input-multi-options.gif)

- [`DialogInput.text`](jd:paper:io.papermc.paper.registry.data.dialog.input.DialogInput#text(java.lang.String,net.kyori.adventure.text.Component))

   一个简单的字符串输入字段

   ![](./assets/dialogs/input-text.gif)

- [`DialogInput.numberRange`](jd:paper:io.papermc.paper.registry.data.dialog.input.DialogInput#numberRange(java.lang.String,net.kyori.adventure.text.Component,float,float))

   一个用于数字输入的滑块

   ![](./assets/dialogs/input-number-range.gif)


### 对话框类型
[`DialogType`](jd:paper:io.papermc.paper.registry.data.dialog.type.DialogType) 接口定义了几种对话框类型的静态方法。
以下是存在的对话框类型：

| 类型               | 方法                                                                                                                                                                                                                                                     | 描述                |
|------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------|
| notice           | [`notice()`](jd:paper:io.papermc.paper.registry.data.dialog.type.DialogType#notice\(\)) 或 [`notice(ActionButton button)`](jd:paper:io.papermc.paper.registry.data.dialog.type.DialogType#notice\(io.papermc.paper.registry.data.dialog.ActionButton\)) | 一个只有一个按钮的简单对话框    |
| confirmation     | [`confirmation(ActionButton yesButton, ActionButton noButton)`](jd:paper:io.papermc.paper.registry.data.dialog.type.DialogType#confirmation\(io.papermc.paper.registry.data.dialog.ActionButton,io.papermc.paper.registry.data.dialog.ActionButton\))  | 一个带有“是”和“否”按钮的对话框 |
| dialog list      | [`dialogList(RegistrySet dialogs)`](jd:paper:io.papermc.paper.registry.data.dialog.type.DialogType#dialogList\(io.papermc.paper.registry.set.RegistrySet\))                                                                                            | 用于打开指定对话框的对话框     |
| multiple actions | [`multiAction(List<ActionButton> actions)`](jd:paper:io.papermc.paper.registry.data.dialog.type.DialogType#multiAction\(java.util.List\))                                                                                                              | 用于显示多个按钮的对话框      |
| server links     | [`serverLinks(ActionButton exitAction, int columns, int buttonWidth)`](jd:paper:io.papermc.paper.registry.data.dialog.type.DialogType#serverLinks\(io.papermc.paper.registry.data.dialog.ActionButton,int,int\))                                       | 服务器链接对话框          |

类型主要影响对话框的底部。

## 在注册表中注册对话框
如果你想让对话框在对话框注册表中注册，你必须在插件的启动器中的注册表修改生命周期事件中注册它们。
关于这方面的基本信息可以阅读[这里](/paper/dev/registries)。

:::tip[提示]

在注册表中注册对话框的优点是，
它允许你在代码的其他地方使用相同的对话框，而无需传递`Dialog`对象。
这也允许在带有对话框参数的命令中引用该对话框。

:::

一般的注册过程与动态创建对话框的过程相当相似：
```java title="YourPluginBootstrapper.java" showLineNumbers
@Override
public void bootstrap(BootstrapContext context) {
    context.getLifecycleManager().registerEventHandler(RegistryEvents.DIALOG.compose()
        .newHandler(event -> event.registry().register(
            DialogKeys.create(Key.key("papermc:custom_dialog")),
            builder -> builder
                // 在这里构建你的对话框……
                .base(DialogBase.builder(Component.text("标题")).build())
                .type(DialogType.notice())
        )));
}
```

## 关闭对话框
可以通过API关闭对话框。有两种方法可以实现这一点：

- 使用 [`Adventure#closeDialog()`](https://jd.advntr.dev/api/latest/net/kyori/adventure/audience/Audience.html#closeDialog()) 的预期方式。
- 使用 [`Player#closeInventory()`](jd:paper:org.bukkit.entity.HumanEntity#closeInventory()) 的稍微有点黑客的方式。

使用 `closeDialog()` 会导致对话框关闭，玩家返回到他们之前所在的非对话框或游戏菜单屏幕。
这意味着任何之前打开的库存将保持打开状态。

相比之下，`closeInventory()` 不仅会关闭当前打开的对话框，还会关闭其他屏幕，比如打开的库存。

## 示例：一个阻塞的确认对话框
如果你想让玩家在加入你的服务器之前阅读一些信息、同意某件事或提供一般输入，
你可以在配置阶段向他们发送一个对话框。
在这个示例中，我们将创建前面展示的对话框。

### 对话框
这个对话框是一个简单的确认类型对话框，包含一个纯文本消息主体组件。
我们将在启动器中注册它，
以便我们可以在 `AsyncPlayerConnectionConfigureEvent` 中轻松检索它，对话框将从这里发送。

```java title="CustomPluginBootstrapper.java" showLineNumbers
ctx.getLifecycleManager().registerEventHandler(RegistryEvents.DIALOG.compose(),
    e -> e.registry().register(
        DialogKeys.create(Key.key("papermc:praise_paperchan")),
        builder -> builder
            .base(DialogBase.builder(Component.text("接受我们的规则！", NamedTextColor.LIGHT_PURPLE))
                .canCloseWithEscape(false)
                .body(List.of(
                    DialogBody.plainMessage(Component.text("加入我们的服务器，即表示你同意 Paper-chan 很可爱！"))
                ))
                .build()
            )
            .type(DialogType.confirmation(
                ActionButton.builder(Component.text("Paper-chan 很可爱！", TextColor.color(0xEDC7FF)))
                    .tooltip(Component.text("点击以同意！"))
                    .action(DialogAction.customClick(Key.key("papermc:paperchan/agree"), null))
                    .build(),
                ActionButton.builder(Component.text("我讨厌 Paper-chan！", TextColor.color(0xFF8B8E)))
                    .tooltip(Component.text("如果你是个坏人，就点击这个！"))
                    .action(DialogAction.customClick(Key.key("papermc:paperchan/disagree"), null))
                    .build()
            ))
    )
);
```

注意确认 `ActionButton` 上的 `.action` 方法。
这些方法包含一个键和一个可选的自定义 NBT 负载，当玩家点击其中一个按钮时，这些内容将从客户端发送到服务器。
我们用它来识别点击事件。

这个示例为两个键分别使用了两个不同的键，但你也可以只使用一个键并设置一个自定义的 NBT 负载。

### 要求玩家同意后才能加入
为了阻止玩家加入服务器，我们向他们发送对话框并等待响应。
我们通过构建一个 `CompletableFuture`，将其放入一个映射中，
并等待该未来完成（这只有在玩家按下对话框中的两个确认按钮之一时才会发生）来实现这一点。

代码可能如下所示：

<details>
  <summary>游戏内预览</summary>
  <Video src={DialogShowcaseMp4} />
</details>

```java title="ServerJoinListener.java" showLineNumbers
@NullMarked
public class ServerJoinListener implements Listener {

    /**
     * 一个用于保存所有当前正在连接的玩家的映射表。
     */
    private final Map<PlayerCommonConnection, CompletableFuture<Boolean>> awaitingResponse = new HashMap<>();

    @EventHandler
    void onPlayerConfigure(AsyncPlayerConnectionConfigureEvent event) {
        Dialog dialog = RegistryAccess.registryAccess().getRegistry(RegistryKey.DIALOG).get(Key.key("papermc:praise_paperchan"));
        if (dialog == null) {
            // 对话框加载失败 :(
            // 如果提供的键无法在注册表中找到对话框，则会发生这种情况。
            // 通常这表明使用的键与注册对话框时使用的键不同，
            // 启动器可能未注册，或者在启动阶段发生了异常。
            return;
        }

        // 构造一个没有任务的新可完成的未来。
        CompletableFuture<Boolean> response = new CompletableFuture<>();

        // 将其放入我们的映射表中。
        awaitingResponse.put(event.getConnection(), response);

        // 向正在连接的玩家展示对话框。
        event.getConnection().getAudience().showDialog(dialog);

        // 等待未来完成。这一步是必要的，以保持玩家在配置阶段。
        if (!response.join()) {
            // 如果响应是`false`，则表示他们拒绝了。因此，我们将他们从服务器中踢出。
            event.getConnection().disconnect(Component.text("你讨厌 Paper-chan :(", NamedTextColor.RED));
        }

        // 我们清理映射表，以避免不必要的条目堆积。
        awaitingResponse.remove(event.getConnection());
    }

    /**
     * 一个用于处理对话框按钮点击事件的事件。
     */
    @EventHandler
    void onHandleDialog(PlayerCustomClickEvent event) {
        Key key = event.getIdentifier();

        if (key.equals(Key.key("papermc:paperchan/disagree"))) {
            // 如果标识符与不同意的那个相同，则将连接结果设置为`false`。
            setConnectionJoinResult(event.getCommonConnection(), false);
        } else if (key.equals(Key.key("papermc:paperchan/agree"))) {
            // 如果它与同意的那个相同，则将结果设置为`true`。
            setConnectionJoinResult(event.getCommonConnection(), true);
        }
    }

    /**
     * 一个简单的工具方法，用于设置连接的对话框响应结果。
     */
    private void setConnectionJoinResult(PlayerCommonConnection connection, boolean value) {
        CompletableFuture<Boolean> future = awaitingResponse.get(connection);
        if (future != null) {
            future.complete(value);
        }
    }
}
```

这就是全部内容。
你可以使用这段代码，在允许玩家加入你的服务器之前阻止他们。

## 示例：检索和解析用户输入
这个示例中的对话框将非常简单：我们再次创建一个确认类型的对话框，其中包含两个数字范围输入。
顶部输入用于设置等级，底部输入用于设置向下一个等级的经验百分比。
当玩家点击确认按钮时，他们的等级和经验值应设置为配置的值。

```java showLineNumbers
Dialog.create(builder -> builder.empty()
    .base(DialogBase.builder(Component.text("配置你的新经验值"))
        .inputs(List.of(
            DialogInput.numberRange("等级", Component.text("等级", NamedTextColor.GREEN), 0f, 100f)
                .step(1f)
                .initial(0f)
                .width(300)
                .build(),
            DialogInput.numberRange("经验", Component.text("经验", NamedTextColor.GREEN), 0f, 100f)
                .step(1f)
                .initial(0f)
                .labelFormat("%s: 距离下一个等级还有 %s")
                .width(300)
                .build()
        ))
        .build()
    )
    .type(DialogType.confirmation(
        ActionButton.create(
            Component.text("确认", TextColor.color(0xAEFFC1)),
            Component.text("点击以确认你的输入。"),
            100,
            DialogAction.customClick(Key.key("papermc:user_input/confirm"), null)
        ),
        ActionButton.create(
            Component.text("Discard", TextColor.color(0xFFA0B1)),
            Component.text("点击以丢弃你的输入。"),
            100,
            null // 如果我们把动作设置为`null`，它什么也不做，只是关闭对话框
        )
    ))
);
```

### 读取输入
为了检索用户在对话框中输入的值，我们再次监听一个 `PlayerCustomClickEvent`。
我们首先检查动作的标识符。
之后，我们可以从通过 [`PlayerCustomClickEvent#getDialogResponseView()`](jd:paper:io.papermc.paper.event.player.PlayerCustomClickEvent#getDialogResponseView())
可获取的 [`DialogResponseView`](jd:paper:io.papermc.paper.dialog.DialogResponseView) 中检索输入值。

这个视图允许我们通过字段的键检索输入字段的值。
这些键在 `DialogInput.numberRange` 方法的第一个参数中声明。

最后一个问题是从此事件中获取玩家对象。
我们不能直接调用 `event.getPlayer()`。
相反，我们必须将通过 [`PlayerCustomClickEvent#getCommonConnection()`](jd:paper:io.papermc.paper.event.player.PlayerCustomClickEvent#getCommonConnection()) 可获取的连接强制转换为 `PlayerGameConnection`，然后从中获取玩家。

完整的事件处理器代码如下所示：

<details>
  <summary>游戏内预览</summary>
  <Video src={InputDialogShowcaseMp4} />
</details>

```java
@EventHandler
void handleLevelsDialog(PlayerCustomClickEvent event) {
    if (!event.getIdentifier().equals(Key.key("papermc:user_input/confirm"))) {
        return;
    }

    DialogResponseView view = event.getDialogResponseView();
    if (view == null) {
        return;
    }

    int levels = view.getFloat("等级").intValue();
    float exp = view.getFloat("经验").floatValue();

    if (event.getCommonConnection() instanceof PlayerGameConnection conn) {
        Player player = conn.getPlayer();
        player.sendRichMessage("你选择了<color:#ccfffd><level>等级</color>和<color:#ccfffd><exp>%经验</color>到下一个等级！",
            Placeholder.component("等级", Component.text(levels)),
            Placeholder.component("经验", Component.text(exp))
        );
        player.setLevel(levels);
        player.setExp(exp / 100);
    }
}
```

### 使用回调

你可以使用
`DialogAction.customClick(DialogActionCallback, ClickCallback.Options)`方法在本地注册一个回调，
而不是注册另一个事件处理器。

因此，对话框操作的代码如下所示：

```java showLineNumbers
DialogAction.customClick(
    (view, audience) -> {
        int levels = view.getFloat("等级").intValue();
        float exp = view.getFloat("经验").floatValue();

        if (audience instanceof Player player) {
            player.sendRichMessage("你选择了<color:#ccfffd><level>等级</color>和<color:#ccfffd><exp>%经验</color>到下一个等级！",
                Placeholder.component("等级", Component.text(levels)),
                Placeholder.component("经验", Component.text(exp))
            );

            player.setLevel(levels);
            player.setExp(exp / 100);
        }
    },
    ClickCallback.Options.builder()
        .uses(1) // 设置此回调的使用次数。默认为 1
        .lifetime(ClickCallback.DEFAULT_LIFETIME) // 设置回调的生命周期。默认为 12 小时
        .build()
)
```
