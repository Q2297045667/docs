---
title: 对话 API
description: 1.21.7 版本中引入的对话 API 指南。
slug: paper/dev/dialogs
version: 1.21.8
sidebar:
  badge:
    text: 实验性
    variant: danger
---

import Video from "/src/components/Video.astro";

import DialogShowcaseMp4 from "./assets/dialogs/dialog-showcase.mp4?url";
import InputDialogShowcaseMp4 from "./assets/dialogs/input-dialog-showcase.mp4?url";

:::danger[实验性]

对话 API 目前处于实验阶段，未来可能会发生变化。

:::

[对话](https://minecraft.wiki/w/Dialog ) 是在 Minecraft [1.21.6](https://minecraft.wiki/w/Java_Edition_1.21.6 ) 更新中新增的功能。
Paper 在 1.21.7 中发布了用于创建自定义对话的开发者 API。
本节旨在介绍此 API 以及您可以和不可以在对话中做的事情。

## 什么是对话？
对话框是服务器向客户端发送自定义游戏内菜单的一种方式。
它们可以用于显示各种信息，或者提供一种便捷的方式收集用户输入。

对话框可以在配置阶段或正常游戏过程中展示给玩家，这使得它们成为一种非常灵活的工具。
一个简单的对话框可能如下所示：

![在配置阶段发送的对话框](./assets/dialogs/confirmation-dialog.png)

此处展示的对话框是一个**确认**类型的对话框，
这意味着它总是包含两个按钮，一个用于确认，一个用于拒绝。

## 展示对话框
可以通过 `/dialog show <players> <dialog>` 命令在游戏中展示对话框。
或者，你也可以通过 API 使用 [Audience#showDialog(DialogLike)](https://jd.advntr.dev/api/latest/net/kyori/adventure/audience/Audience.html#showDialog(net.kyori.adventure.dialog.DialogLike)) 来展示它们。
你可以从 [`Dialog`](jd:paper:io.papermc.paper.dialog.Dialog) 接口中静态获取内置对话框。
新对话框可以使用 [`Dialog#create`](jd:paper:io.papermc.paper.dialog.Dialog#create(java.util.function.Consumer)) 动态创建，
或者如果在启动阶段注册，可以通过 `RegistryAccess.registryAccess().getRegistry(RegistryKey.DIALOG).get(Key)` 从对话框注册表中获取。

## 内置对话框
有三种内置对话框：
- [服务器链接](jd:paper:io.papermc.paper.registry.keys.DialogKeys#SERVER_LINKS)
- [快速操作](jd:paper:io.papermc.paper.registry.keys.DialogKeys#QUICK_ACTIONS)
- [自定义选项](jd:paper:io.papermc.paper.registry.keys.DialogKeys#CUSTOM_OPTIONS)

### 添加服务器链接
你可以通过从 [`Bukkit.getServer().getServerLinks()`](jd:paper:org.bukkit.Server#getServerLinks()) 获取 [`ServerLinks`](jd:paper:org.bukkit.ServerLinks) 实例，
并使用各种修改方法来添加服务器链接。
玩家可以通过打开游戏菜单（按下 `esc` 键）并点击 `服务器链接...` 按钮，随时打开服务器链接菜单。
此按钮仅在存在服务器链接时才会显示。

## 动态创建对话框
你可以使用 [`Dialog#create`](jd:paper:io.papermc.paper.dialog.Dialog#create(java.util.function.Consumer)) 方法构建一个 [`Dialog`](jd:paper:io.papermc.paper.dialog.Dialog) 对象。
Consumer 参数允许你构建对话框。
**对话框总是需要一个基础和一个类型**，这可以在构建器中声明。
你可以创建一个新的对话框，或者使用一个现有的[注册表注册的](#registering-dialogs-in-the-register)对话框作为基础。

作为参考，一个非常简单的（通知类型）对话框可以通过以下代码构建并展示给玩家：

<details>
  <summary>游戏内预览</summary>
  ![仅包含标题和确定按钮的对话框](./assets/dialogs/notice-dialog.png)
</details>

```java
Dialog dialog = Dialog.create(builder -> builder.empty()
    .base(DialogBase.builder(Component.text("Title")).build())
    .type(DialogType.notice())
);
player.showDialog(dialog);
```

### 对话框基础
你可以使用其[构建器](jd:paper:io.papermc.paper.registry.data.dialog.DialogBase$Builder)创建对话框基础，
该构建器可以通过 [`DialogBase.builder(Component title)`](jd:paper:io.papermc.paper.registry.data.dialog.DialogBase#builder(net.kyori.adventure.text.Component)) 创建。
对话框基础可以声明以下值：

| 构建器方法                                                                                                                                                                                    | 描述                |
|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------|
| [`afterAction(DialogAfterAction)`](jd:paper:io.papermc.paper.registry.data.dialog.DialogBase\$Builder#afterAction\(io.papermc.paper.registry.data.dialog.DialogBase.DialogAfterAction\)) | 对话框关闭后要执行的操作      |
| [`canCloseWithEscape(boolean)`](jd:paper:io.papermc.paper.registry.data.dialog.DialogBase\$Builder#canCloseWithEscape\(boolean\))                                                        | 是否可以通过`esc`键关闭对话框 |
| [`externalTitle(Component)`](jd:paper:io.papermc.paper.registry.data.dialog.DialogBase\$Builder#externalTitle\(net.kyori.adventure.text.Component\))                                     | 在打开此对话框的按钮上显示的标题  |
| [`body(List<? extends DialogBody>)`](jd:paper:io.papermc.paper.registry.data.dialog.DialogBase\$Builder#body\(java.util.List\))                                                          | 对话框的主体内容。         |
| [`inputs(List<? extends DialogInput>)`](jd:paper:io.papermc.paper.registry.data.dialog.DialogBase\$Builder#inputs\(java.util.List\))                                                     | 对话框的输入内容。         |

#### 对话框主体
对话框可以包含任意数量的主体组件。
可以通过 [`DialogBody.plainMessage(Component)`](jd:paper:io.papermc.paper.registry.data.dialog.body.DialogBody#plainMessage(net.kyori.adventure.text.Component)) 创建用于显示文本的主体条目，
或者通过 [`DialogBody.item(ItemStack)`](jd:paper:io.papermc.paper.registry.data.dialog.body.DialogBody#item(org.bukkit.inventory.ItemStack)) 创建用于显示物品的主体条目。

#### 对话框输入
有四种收集输入的方式：

- [`DialogInput.bool`](jd:paper:io.papermc.paper.registry.data.dialog.input.DialogInput#bool(java.lang.String,net.kyori.adventure.text.Component))

   一个简单的复选框，表示真或假的状态

   ![](./assets/dialogs/input-boolean.gif)

- [`DialogInput.singleOption`](jd:paper:io.papermc.paper.registry.data.dialog.input.DialogInput#singleOption(java.lang.String,net.kyori.adventure.text.Component,java.util.List))

   一个多项选择按钮

   ![](./assets/dialogs/input-multi-options.gif)

- [`DialogInput.text`](jd:paper:io.papermc.paper.registry.data.dialog.input.DialogInput#text(java.lang.String,net.kyori.adventure.text.Component))

   一个简单的字符串输入字段

   ![](./assets/dialogs/input-text.gif)

- [`DialogInput.numberRange`](jd:paper:io.papermc.paper.registry.data.dialog.input.DialogInput#numberRange(java.lang.String,net.kyori.adventure.text.Component,float,float))

   一个用于数字输入的滑块

   ![](./assets/dialogs/input-number-range.gif)


### 对话框类型
[`DialogType`](jd:paper:io.papermc.paper.registry.data.dialog.type.DialogType) 接口定义了几种对话框类型的静态方法。
以下是存在的对话框类型：

| 类型               | 方法                                                                                                                                                                                                                                                     | 描述                |
|------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------|
| notice           | [`notice()`](jd:paper:io.papermc.paper.registry.data.dialog.type.DialogType#notice\(\)) 或 [`notice(ActionButton button)`](jd:paper:io.papermc.paper.registry.data.dialog.type.DialogType#notice\(io.papermc.paper.registry.data.dialog.ActionButton\)) | 一个只有一个按钮的简单对话框    |
| confirmation     | [`confirmation(ActionButton yesButton, ActionButton noButton)`](jd:paper:io.papermc.paper.registry.data.dialog.type.DialogType#confirmation\(io.papermc.paper.registry.data.dialog.ActionButton,io.papermc.paper.registry.data.dialog.ActionButton\))  | 一个带有“是”和“否”按钮的对话框 |
| dialog list      | [`dialogList(RegistrySet dialogs)`](jd:paper:io.papermc.paper.registry.data.dialog.type.DialogType#dialogList\(io.papermc.paper.registry.set.RegistrySet\))                                                                                            | 用于打开指定对话框的对话框     |
| multiple actions | [`multiAction(List<ActionButton> actions)`](jd:paper:io.papermc.paper.registry.data.dialog.type.DialogType#multiAction\(java.util.List\))                                                                                                              | 用于显示多个按钮的对话框      |
| server links     | [`serverLinks(ActionButton exitAction, int columns, int buttonWidth)`](jd:paper:io.papermc.paper.registry.data.dialog.type.DialogType#serverLinks\(io.papermc.paper.registry.data.dialog.ActionButton,int,int\))                                       | 服务器链接对话框          |

类型主要影响对话框的底部。

## 在注册表中注册对话框
如果你想让对话框在对话框注册表中注册，你必须在插件的启动器中的注册表修改生命周期事件中注册它们。
关于这方面的基本信息可以阅读[这里](/paper/dev/registries)。

:::tip[提示]

在注册表中注册对话框的优点是，
它允许你在代码的其他地方使用相同的对话框，而无需传递`Dialog`对象。
这也允许在带有对话框参数的命令中引用该对话框。

:::

一般的注册过程与动态创建对话框的过程相当相似：
```java title="YourPluginBootstrapper.java" showLineNumbers
@Override
public void bootstrap(BootstrapContext context) {
    context.getLifecycleManager().registerEventHandler(RegistryEvents.DIALOG.compose()
        .newHandler(event -> event.registry().register(
            DialogKeys.create(Key.key("papermc:custom_dialog")),
            builder -> builder
                // 在这里构建你的对话框……
                .base(DialogBase.builder(Component.text("Title")).build())
                .type(DialogType.notice())
        )));
}
```

## 关闭对话框
可以通过API关闭对话框。有两种方法可以实现这一点：

- 使用 [`Adventure#closeDialog()`](https://jd.advntr.dev/api/latest/net/kyori/adventure/audience/Audience.html#closeDialog()) 的预期方式。
- 使用 [`Player#closeInventory()`](jd:paper:org.bukkit.entity.HumanEntity#closeInventory()) 的稍微有点黑客的方式。

Using `closeDialog()` will result in the dialog being closed and the player returning to the previous non-dialog or game menu screen they were on.
This means any previously open inventories will be kept open.

In contrast, `closeInventory()` will close not only the currently open dialog, but also any other screens, like an open inventory.

## Example: A blocking confirmation dialog
If you want your players to read some information, agree to something, or give general input before they join your server,
you can send them a dialog during the configuration phase. For this example, we will be creating the dialog shown at
the start.

### The dialog
The dialog is a simple confirmation-type dialog with a single plain message body components. We will register it in
the bootstrapper so that we can easily retrieve it from the `AsyncPlayerConnectionConfigureEvent`, where the dialog will
be sent from.

```java title="CustomPluginBootstrapper.java" showLineNumbers
ctx.getLifecycleManager().registerEventHandler(RegistryEvents.DIALOG.compose(),
    e -> e.registry().register(
        DialogKeys.create(Key.key("papermc:praise_paperchan")),
        builder -> builder
            .base(DialogBase.builder(Component.text("Accept our rules!", NamedTextColor.LIGHT_PURPLE))
                .canCloseWithEscape(false)
                .body(List.of(
                    DialogBody.plainMessage(Component.text("By joining our server you agree that Paper-chan is cute!"))
                ))
                .build()
            )
            .type(DialogType.confirmation(
                ActionButton.builder(Component.text("Paper-chan is cute!", TextColor.color(0xEDC7FF)))
                    .tooltip(Component.text("Click to agree!"))
                    .action(DialogAction.customClick(Key.key("papermc:paperchan/agree"), null))
                    .build(),
                ActionButton.builder(Component.text("I hate Paper-chan!", TextColor.color(0xFF8B8E)))
                    .tooltip(Component.text("Click this if you are a bad person!"))
                    .action(DialogAction.customClick(Key.key("papermc:paperchan/disagree"), null))
                    .build()
            ))
    )
);
```

Notice the `.action` methods on the confirmation `ActionButton`s. These hold a key and an optional, custom NBT payload
that will be sent from the client to the server when the player clicks one of the buttons. We use that to identify
the click event.

This example uses two separate keys for both keys, but you can also use only one and set a custom NBT payload.

### Requiring the player to agree before allowing them to join
In order to block the player from joining the server, we send them the dialog and await a response. We do
this by constructing a `CompletableFuture`, putting it into a map, and waiting until the future gets
completed, will only happen as soon the player pressed one of the two confirmation buttons of the dialog.

The code for that would look something like this:

<details>
  <summary>In-game preview</summary>
  <Video src={DialogShowcaseMp4} />
</details>

```java title="ServerJoinListener.java" showLineNumbers
@NullMarked
public class ServerJoinListener implements Listener {

    /**
     * A map for holding all currently connecting players.
     */
    private final Map<PlayerCommonConnection, CompletableFuture<Boolean>> awaitingResponse = new HashMap<>();

    @EventHandler
    void onPlayerConfigure(AsyncPlayerConnectionConfigureEvent event) {
        Dialog dialog = RegistryAccess.registryAccess().getRegistry(RegistryKey.DIALOG).get(Key.key("papermc:praise_paperchan"));
        if (dialog == null) {
            // The dialog failed to load :(
            // This would happen if the dialog could not be found in the registry by the provided key.
            // Usually that is an indicator that the used key is different from the one used to register your
            // dialog, your bootstrapper might not be registered, or an exception occurred in the bootstrap phase.
            return;
        }

        // Construct a new completable future without a task.
        CompletableFuture<Boolean> response = new CompletableFuture<>();

        // Put it into our map.
        awaitingResponse.put(event.getConnection(), response);

        // Show the connecting player the dialog.
        event.getConnection().getAudience().showDialog(dialog);

        // Wait until the future is complete. This step is necessary in order to keep the player in the configuration phase.
        if (!response.join()) {
            // If the response is false, they declined. Therefore, we kick them from the server.
            event.getConnection().disconnect(Component.text("You hate Paper-chan :(", NamedTextColor.RED));
        }

        // We clean the map to avoid unnecessary entry buildup.
        awaitingResponse.remove(event.getConnection());
    }

    /**
     * An event for handling dialog button click events.
     */
    @EventHandler
    void onHandleDialog(PlayerCustomClickEvent event) {
        Key key = event.getIdentifier();

        if (key.equals(Key.key("papermc:paperchan/disagree"))) {
            // If the identifier is the same as the disagree one, set the connection result to false.
            setConnectionJoinResult(event.getCommonConnection(), false);
        } else if (key.equals(Key.key("papermc:paperchan/agree"))) {
            // If it is the same as the agree one, set the result to true.
            setConnectionJoinResult(event.getCommonConnection(), true);
        }
    }

    /**
     * Simple utility method for setting a connection's dialog response result.
     */
    private void setConnectionJoinResult(PlayerCommonConnection connection, boolean value) {
        CompletableFuture<Boolean> future = awaitingResponse.get(connection);
        if (future != null) {
            future.complete(value);
        }
    }
}
```

And that's all there is to it. You can use this code to block players from joining your server before they should
be allowed to.

## Example: Retrieving and parsing user input
The dialog for this example will be fairly simple: We once again create a confirmation-type dialog which contains two number range inputs.
The top input will be for setting the level, the bottom input for setting the experience percentage towards the next level.
When the player clicks on the confirmation button, they should have their levels and exp set to the configured values.

```java showLineNumbers
Dialog.create(builder -> builder.empty()
    .base(DialogBase.builder(Component.text("Configure your new experience value"))
        .inputs(List.of(
            DialogInput.numberRange("level", Component.text("Level", NamedTextColor.GREEN), 0f, 100f)
                .step(1f)
                .initial(0f)
                .width(300)
                .build(),
            DialogInput.numberRange("experience", Component.text("Experience", NamedTextColor.GREEN), 0f, 100f)
                .step(1f)
                .initial(0f)
                .labelFormat("%s: %s percent to the next level")
                .width(300)
                .build()
        ))
        .build()
    )
    .type(DialogType.confirmation(
        ActionButton.create(
            Component.text("Confirm", TextColor.color(0xAEFFC1)),
            Component.text("Click to confirm your input."),
            100,
            DialogAction.customClick(Key.key("papermc:user_input/confirm"), null)
        ),
        ActionButton.create(
            Component.text("Discard", TextColor.color(0xFFA0B1)),
            Component.text("Click to discard your input."),
            100,
            null // If we set the action to null, it doesn't do anything and closes the dialog
        )
    ))
);
```

### Reading the input
To retrieve the values the user put into the dialog, we can once again listen to a `PlayerCustomClickEvent`.
We first check the identifier of the action. After that, we can retrieve the input values from the
[`DialogResponseView`](jd:paper:io.papermc.paper.dialog.DialogResponseView) retrievable from
[`PlayerCustomClickEvent#getDialogResponseView()`](jd:paper:io.papermc.paper.event.player.PlayerCustomClickEvent#getDialogResponseView()).

This view allows us to retrieve the value of an input field with the field's key. Those are declared as the first
parameter of the `DialogInput.numberRange` method.

The last issue is getting a player object from this event. We cannot just call `event.getPlayer()`. Instead, we have
to cast the connection retrievable from [`PlayerCustomClickEvent#getCommonConnection()`](jd:paper:io.papermc.paper.event.player.PlayerCustomClickEvent#getCommonConnection()).
to a [`PlayerGameConnection`](jd:paper:io.papermc.paper.connection.PlayerGameConnection), from which we can get the player.

The full event handler code looks like this:

<details>
  <summary>In-game preview</summary>
  <Video src={InputDialogShowcaseMp4} />
</details>

```java
@EventHandler
void handleLevelsDialog(PlayerCustomClickEvent event) {
    if (!event.getIdentifier().equals(Key.key("papermc:user_input/confirm"))) {
        return;
    }

    DialogResponseView view = event.getDialogResponseView();
    if (view == null) {
        return;
    }

    int levels = view.getFloat("level").intValue();
    float exp = view.getFloat("experience").floatValue();

    if (event.getCommonConnection() instanceof PlayerGameConnection conn) {
        Player player = conn.getPlayer();
        player.sendRichMessage("You selected <color:#ccfffd><level> levels</color> and <color:#ccfffd><exp>% exp</color> to the next level!",
            Placeholder.component("level", Component.text(levels)),
            Placeholder.component("exp", Component.text(exp))
        );
        player.setLevel(levels);
        player.setExp(exp / 100);
    }
}
```

### Using callbacks

Instead of registering another event handler, you can instead use the
[`DialogAction.customClick(DialogActionCallback, ClickCallback.Options)`](jd:paper:io.papermc.paper.registry.data.dialog.action.DialogAction#customClick(io.papermc.paper.registry.data.dialog.action.DialogActionCallback,net.kyori.adventure.text.event.ClickCallback.Options))
method to register a callback locally.

The code for the dialog action would therefore look like this:

```java showLineNumbers
DialogAction.customClick(
    (view, audience) -> {
        int levels = view.getFloat("level").intValue();
        float exp = view.getFloat("experience").floatValue();

        if (audience instanceof Player player) {
            player.sendRichMessage("You selected <color:#ccfffd><level> levels</color> and <color:#ccfffd><exp>% exp</color> to the next level!",
                Placeholder.component("level", Component.text(levels)),
                Placeholder.component("exp", Component.text(exp))
            );

            player.setLevel(levels);
            player.setExp(exp / 100);
        }
    },
    ClickCallback.Options.builder()
        .uses(1) // Set the number of uses for this callback. Defaults to 1
        .lifetime(ClickCallback.DEFAULT_LIFETIME) // Set the lifetime of the callback. Defaults to 12 hours
        .build()
)
```
