---
title: 粒子
description: 一份关于粒子生成的全面指南。
slug: paper/dev/particles
version: 1.21.5
---

import { Tabs, TabItem, Badge } from "@astrojs/starlight/components";
import NoteParticleColorPicker from "/src/components/tools/NoteParticleColorPicker.svelte";

这份指南解释了如何生成不同类型的粒子。

如果你尝试生成的粒子没有在这份指南中提到，那么它很可能没有特殊行为。

有两种方法可以生成粒子。
第一种选择是使用 `ParticleBuilder` 类，
这比 `spawnParticle()` 方法更受推荐。
它具有可重用性，并且提供了更好的可读性和清晰度。
构建器还包括 `receivers()` 方法，它为你提供了对接收者的更大控制权。

一个在 4x0.4x4 的长方体中生成 14 个音符粒子的例子：
```java
Particle.NOTE.builder()
  .location(someLocation)
  .offset(2, 0.2, 2)
  .count(14)
  .receivers(32, true)
  .spawn();
```

:::note[注意]
使用 [`ParticleBuilder.receivers(32, true)`](jd:paper:com.destroystokyo.paper.ParticleBuilder#receivers(int,boolean))
会选择距离粒子位置32格范围内的所有玩家，形成一个球形区域。
如果将布尔参数设置为 `false`，则会选择一个立方体内的所有玩家。
:::

第二种方法是使用 `World` 和 `Player` 类中的 `spawnParticle()` 方法：
- [`World.spawnParticle()`](jd:paper:org.bukkit.World#spawnParticle(org.bukkit.Particle,double,double,double,int)) ，它为所有玩家生成粒子。
- [`Player.spawnParticle()`](jd:paper:org.bukkit.entity.Player#spawnParticle(org.bukkit.Particle,double,double,double,int)) ，它只为特定玩家生成粒子。

## `count` argument behavior <Badge variant="danger" text="Important" size="large" />
在生成粒子时，Minecraft客户端会根据`count`参数的不同而表现出不同的行为：
- 如果 `count = 0`，会生成一个单独的粒子，客户端会直接使用提供的位置而不进行任何修改。
偏移值会乘以 `extra` 参数，然后传递给粒子构造器。
这些值的使用方式可能会因粒子类型而有所不同。

- 如果 `count > 0`，客户端会生成 `count` 数量的粒子。
对于每个粒子，它会使用高斯（正态）分布生成新的偏移值，
将这些值乘以 `extra` 参数，然后传递给粒子构造器。

## 定向粒子
这种类型的粒子在生成时具有初始速度。

:::note[注意]
不同粒子的有效速度会有所不同。
:::

在以下示例中，8个`FLAME`粒子在1x1x1的立方体形状内随机生成，`someLocation`作为其中心。
`extra`参数设置为0，因此粒子不会移动。
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    Particle.FLAME.builder()
      .location(someLocation)
      .offset(0.5, 0.5, 0.5)
      .count(8)
      .extra(0)
      .receivers(32, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.FLAME, someLocation, 8, 0.5, 0.5, 0.5, 0);
    ```
  </TabItem>
</Tabs>

:::caution[警告]
如果不设置 `extra` 参数，它将默认为 `1`，这可能会导致意外的行为。
:::

### 随机方向
将 `count` 参数设置为任何正值，
都会根据 [`count` argument behavior](#count-argument-behavior) 参数的行为描述，为速度产生一个随机方向。

一个在某个位置生成 6 个 `CRIT` 粒子的例子，这些粒子没有偏移，并将以适中的速度向随机方向移动：
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    Particle.CRIT.builder()
      .location(someLocation)
      .count(6)
      .extra(0.6)
      .receivers(32, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.CRIT, someLocation, 6, 0, 0, 0, 0.6);
    ```
  </TabItem>
</Tabs>

![CRIT粒子向随机方向移动](./assets/particles/random-direction-crit.webp)

### 指定方向
要指定速度的方向，需将 `count` 参数设置为 `0`，并使用偏移参数作为方向向量。
更多详情请参见 [`count` 参数行为](#count-argument-behavior)。

一个重复任务的示例，生成缓慢向上（正 Y 轴方向）飘动的篝火烟雾：
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    ParticleBuilder particleBuilder = Particle.CAMPFIRE_SIGNAL_SMOKE.builder()
      .location(someLocation)
      .offset(0, 1, 0)
      .count(0)
      .extra(0.1);

    Bukkit.getScheduler().runTaskTimer(plugin,
      () -> particleBuilder.receivers(32, true).spawn(),
    0, 4);
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    Bukkit.getScheduler().runTaskTimer(plugin,
      () -> someWorld.spawnParticle(Particle.CAMPFIRE_SIGNAL_SMOKE, someLocation, 0, 0, 1, 0, 0.1),
      0, 4);
    ```
  </TabItem>
</Tabs>

![篝火信号烟向上飘](./assets/particles/smoke-going-up.webp)

如果需要，我们也可以让烟向下飘。
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    ParticleBuilder particleBuilder = Particle.CAMPFIRE_SIGNAL_SMOKE.builder()
      .location(someLocation)
      .offset(0, -1, 0)
      .count(0)
      .extra(0.1);

    Bukkit.getScheduler().runTaskTimer(plugin,
      () -> particleBuilder.receivers(32, true).spawn(),
    0, 4);
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    Bukkit.getScheduler().runTaskTimer(plugin,
      () -> someWorld.spawnParticle(Particle.CAMPFIRE_SIGNAL_SMOKE, someLocation, 0, 0, -1, 0, 0.1),
      0, 4);
    ```
  </TabItem>
</Tabs>

{/* spellchecker:off */}
### 定向粒子列表
<details>
<summary>展示列表</summary>
- BLOCK
- BUBBLE
- BUBBLE_COLUMN_UP
- BUBBLE_POP
- CAMPFIRE_COSY_SMOKE
- CAMPFIRE_SIGNAL_SMOKE
- CLOUD
- CRIT
- DAMAGE_INDICATOR
- DRAGON_BREATH
- DUST
- DUST_COLOR_TRANSITION
- DUST_PLUME
- ELECTRIC_SPARK
- ENCHANTED_HIT
- END_ROD
- FIREWORK
- FISHING
- FLAME
- FLASH
- GLOW_SQUID_INK
- ITEM
- LARGE_SMOKE
- POOF
- REVERSE_PORTAL
- SCRAPE
- SCULK_CHARGE
- SCULK_CHARGE_POP
- SCULK_SOUL
- SMALL_FLAME
- SMOKE
- SNEEZE
- SNOWFLAKE
- SOUL
- SOUL_FIRE_FLAME
- SPIT
- SQUID_INK
- TOTEM_OF_UNDYING
- TRIAL_SPAWNER_DETECTION
- TRIAL_SPAWNER_DETECTION_OMINOUS
- WAX_OFF
- WAX_ON
- WHITE_SMOKE

</details>
{/* spellchecker:on */}

## 彩色颗粒
这些颗粒可以通过传递一个 [`Color`](jd:paper:org.bukkit.Color) 对象作为 `data` 参数来着色。

在 2x2x2 区域内生成 10 个带有略微半透明橙色的药水效果颗粒的示例：
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    Particle.ENTITY_EFFECT.builder()
      .location(someLocation)
      .offset(1, 1, 1)
      .count(10)
      .data(Color.fromARGB(200, 255, 128, 0))
      .receivers(32, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.ENTITY_EFFECT, someLocation, 10, 1, 1, 1, Color.fromARGB(200, 255, 128, 0));
    ```
  </TabItem>
</Tabs>

![彩色药水效果颗粒](./assets/particles/orange-spell-particles.webp)

:::note[注意]
只有 `ENTITY_EFFECT` 支持 alpha 通道，用于创建半透明颗粒。
:::

:::caution[警告]
`EFFECT` 和 `INSTANT_EFFECT` 颗粒无法通过API着色，它们始终是白色的。
只有投掷的药水才能为它们着色。
:::

### 尘埃颗粒
原版游戏中使用尘埃颗粒来表示红石颗粒。
通过将 [Particle.DustOptions](jd:paper:org.bukkit.Particle$DustOptions) 作为 `data` 参数传递，可以为其设置自定义颜色。

:::note[注意]
缩放因子必须在 `0.01` 到 `4.0` 的范围内。超出此范围的值将被限制为最近的有效值。
:::

创建一条蓝色尘埃颗粒的垂直线，颗粒大小是常规大小的两倍的示例：
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    ParticleBuilder particleBuilder = Particle.DUST.builder()
      .color(Color.BLUE, 2.0f);

    // 我们可以重用构建器
    for (double i = -1.0; i <= 1.0; i += 0.25) {
      particleBuilder.location(someLocation.clone().add(0, i, 0)).receivers(32, true).spawn();
    }
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    for (double i = -1.0; i <= 1.0; i += 0.25) {
      someWorld.spawnParticle(
        Particle.DUST,
        someLocation.clone().add(0, i, 0),
        1,
        new Particle.DustOptions(Color.BLUE, 2.0f)
      );
    }
    ```
  </TabItem>
</Tabs>

![一条蓝色尘埃颗粒的垂直线](./assets/particles/blue-dust-particles-in-line.webp)

:::note[注意]
在这里，添加一个大小参数可以控制尘埃颗粒的持续时间，以刻为单位。
默认情况下，该值是一个介于 8 到 40 之间的随机整数，该值乘以颗粒的缩放比例，以获得最终的持续时间（最小值为 1）。
:::

#### 尘埃过渡颗粒
尘埃过渡颗粒的工作原理与[尘埃颗粒](#dust-particles)完全相同，
但它们不是具有静态颜色，而是会从一种颜色**过渡**到另一种颜色。
使用 [Particle.DustTransition](jd:paper:org.bukkit.Particle$DustTransition) 来指定这种过渡。

一个示例，在 1 格长度的 x 轴上生成三个尘埃过渡颗粒：
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    Particle.DUST_COLOR_TRANSITION.builder()
      .location(someLocation)
      .offset(0.5, 0, 0)
      .count(3)
      .colorTransition(Color.RED, Color.BLUE)
      .receivers(32, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(
      Particle.DUST_COLOR_TRANSITION,
      someLocation,
      3,
      0.5, 0, 0,
      new Particle.DustTransition(Color.RED, Color.BLUE, 1.0f)
    );
    ```
  </TabItem>
</Tabs>

![一条线上的尘埃过渡颗粒](./assets/particles/dust-transition-particles.webp)

### 注意颗粒
注意颗粒会使用 `offsetX` 参数在一个自定义函数中确定颜色，更多详情请参阅[音符颗粒颜色选择器](#note-particle-color-picker)。
在这种情况下，`offsetY` 和 `offsetZ` 会被忽略。

示例：
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    Particle.NOTE.builder()
      .location(someLocation)
      .offset(0.4f, 0, 0)
      .count(0)
      .receivers(32, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.NOTE, someLocation, 0, 0.4f, 0, 0);
    ```
  </TabItem>
</Tabs>

![注意颗粒](./assets/particles/note-particle.webp)

#### 音符颗粒颜色选择器
这个工具允许您通过调整 `offsetX` 值来选择音符颗粒的颜色。
它只允许您选择介于 `-1.0` 到 `1.0`之间的 `offsetX` 值；超出此范围的值将重复颜色模式。
<NoteParticleColorPicker client:load />

:::tip[提示]
要实现原版游戏中的音符颗粒颜色，您必须将`offsetX`设置为24的分数。

示例：
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    Particle.NOTE.builder()
      .location(someLocation)
      .offset(2.0f/24.0f, 0, 0)
      .count(0)
      .receivers(32, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.NOTE, someLocation, 0, 2.0f/24.0f, 0, 0);
    ```
  </TabItem>
</Tabs>
:::

### Trail particles
Trail particles require you to pass a [`Particle.Trail`](jd:paper:org.bukkit.Particle$Trail) object as `data`.

An example where eight randomly offset trail particles travel towards a specified location
(`someLocation.clone().add(-4, 0, 4)`) with a yellow color and a travel time of 40 ticks:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    Particle.TRAIL.builder()
      .location(someLocation)
      .offset(1, 1, 1)
      .count(8)
      .data(new Particle.Trail(someLocation.clone().add(-4, 0, 4), Color.YELLOW, 40))
      .receivers(32, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(
      Particle.TRAIL,
      someLocation,
      8,
      1, 1, 1,
      new Particle.Trail(someLocation.clone().add(-4, 0, 4), Color.YELLOW, 40)
    );
    ```
  </TabItem>
</Tabs>

![Yellow trail particles floating towards the right side of the screen](./assets/particles/trail-particles.webp)

## Converging particles
As the name implies, this type of particle converges to a single point (location), which in this case is the supplied location.
Offset arguments are used to determine the relative spawn location of the particle.
The particle will then travel from this relative location to the supplied location.

An example where an enchantment particle will spawn at `someLocation.clone().add(-2, 0, 2)` and travel to `someLocation`:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    Particle.ENCHANT.builder()
      .location(someLocation)
      .offset(-2, 0, 2)
      .count(0)
      .receivers(32, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.ENCHANT, someLocation, 0, -2, 0, 2);
    ```
  </TabItem>
</Tabs>

![Enchant particle going towards the center of the screen](./assets/particles/converging-enchant-particle.webp)

:::note
There are two types of converging particles:

- **Curving**: Particles that follow a curved path to the specified location.
- **Straight**: Particles that move in a straight line to the specified location.

The `ENCHANT`, `NAUTILUS`, `PORTAL` and `VAULT_CONNECTION` particles use curved paths, while the `OMINOUS_SPAWNING` particle
travels in a straight line.
:::

### List of converging particles
<details>
<summary>Show list</summary>
- ENCHANT
- NAUTILUS
- OMINOUS_SPAWNING
- PORTAL
- VAULT_CONNECTION
</details>

## Material particles
### BlockData
To spawn particles that require `BlockData`, simply put `BlockData` as its `data` argument.

Example:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    Particle.BLOCK_CRUMBLE.builder()
      .location(someLocation)
      .count(4)
      .data(BlockType.GLOWSTONE.createBlockData())
      .receivers(32, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.BLOCK_CRUMBLE, someLocation, 4, BlockType.GLOWSTONE.createBlockData());
    ```
  </TabItem>
</Tabs>

:::note
This guide uses [`BlockType.createBlockData()`](jd:paper:org.bukkit.block.BlockType#createBlockData()). While using
[`Material.createBlockData()`](jd:paper:org.bukkit.Material#createBlockData()) or
[`Bukkit.createBlockData(Material)`](jd:paper:org.bukkit.Bukkit#createBlockData(org.bukkit.Material)) yields the same result,
they are considered **legacy**.
:::

:::tip
The `BLOCK` particle is a [directional particle](#directional-particles).

In this case, **velocity matters** a lot. A higher velocity will ensure the same general direction of the particle, while a lower one will
result in a more random direction.

To achieve this, the effective velocity vector's length should be high (around 10 is fine).
:::

### ItemStack
To spawn particles that require an `ItemStack`, simply put an `ItemStack` as its `data` argument.

Example:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    Particle.ITEM.builder()
      .location(someLocation)
      .count(4)
      .data(ItemStack.of(Material.DIAMOND_PICKAXE))
      .receivers(32, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.ITEM, someLocation, 4, ItemStack.of(Material.DIAMOND_PICKAXE));
    ```
  </TabItem>
</Tabs>

:::note
This guide uses [`ItemStack.of(Material)`](jd:paper:org.bukkit.inventory.ItemStack#of(org.bukkit.Material)). While using
[`new ItemStack(Material)`](jd:paper:org.bukkit.inventory.ItemStack) yields the same result,
it is considered **legacy**. [`ItemType.createItemStack()`](jd:paper:org.bukkit.inventory.ItemType#createItemStack())
also yields the same result, but is more likely to get removed in the future.
:::

:::tip
The `ITEM` particle is a [directional particle](#directional-particles).
:::

## Sculk particles
### Sculk charge
The `SCULK_CHARGE` particle takes a `float` as its `data` argument. This is used as the particle's "roll." Or, more formally,
the angle the particle displays at in **radians**.

Example of spawning a sculk charge particle at 45° that doesn't move:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    Particle.SCULK_CHARGE.builder()
      .location(someLocation)
      .data((float) Math.toRadians(45))
      .extra(0)
      .receivers(32, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.SCULK_CHARGE, someLocation, 1, 0, 0, 0, 0, (float) Math.toRadians(45));
    ```
  </TabItem>
</Tabs>

![Sculk charge particle at 45°](./assets/particles/sculk-charge.webp)

:::tip
The `SCULK_CHARGE` particle is a [directional particle](#directional-particles).
:::

### Shriek
The `SHRIEK` particle takes an `integer` as its `data` argument. This is used to set the delay **in ticks** before the particle spawns.

It is completely up to your implementation when choosing to use `data` or a scheduler.

Example where a shriek particle will spawn after one second:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    Particle.SHRIEK.builder()
      .location(someLocation)
      .data(20)
      .receivers(32, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.SHRIEK, someLocation, 1, 20);
    ```
  </TabItem>
</Tabs>

![Shriek particle](./assets/particles/shriek.webp)

### Vibration
Vibration particles require you to pass a [`Vibration`](jd:paper:org.bukkit.Vibration) object as `data`, where you can choose between a
location ([`Vibration.Destination.BlockDestination`](jd:paper:org.bukkit.Vibration\$Destination\$BlockDestination))
or an entity target ([`Vibration.Destination.EntityDestination`](jd:paper:org.bukkit.Vibration\$Destination\$EntityDestination)).
The constructor's second argument is the travel time in **ticks**.

An example where a vibration particle will spawn at `someLocation` and travel to `otherLocation` in 40 ticks:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    Particle.VIBRATION.builder()
      .location(someLocation)
      .data(new Vibration(new Vibration.Destination.BlockDestination(otherLocation), 40))
      .receivers(32, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(
      Particle.VIBRATION,
      someLocation,
      1,
      new Vibration(new Vibration.Destination.BlockDestination(otherLocation), 40)
    );
    ```
  </TabItem>
</Tabs>

![Vibration particle going to the left side of the screen](./assets/particles/vibration.webp)

## Rising particles
These particles will use `offsetY` as the particle's y-axis velocity.

If you set `offsetX` AND `offsetZ` to `0`, the particle will have almost no x or z-axis velocity, but will still have
a y-axis velocity set by the `offsetY` argument. In both cases, `offsetX` and `offsetZ` are not used in the velocity vector.

Example of spawning a `GLOW` particle that moves up:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    Particle.GLOW.builder()
      .location(someLocation)
      .count(0)
      .offset(0, 2, 0)
      .receivers(32, true)
      .spawn();
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.GLOW, someLocation, 0, 0, 2, 0);
    ```
  </TabItem>
</Tabs>

![Glow particle going up](./assets/particles/rising-glow-particle.webp)

:::note
These particles rise up, meaning that the initial velocity will be used only briefly, and the particle will
start to travel up after a short time. Therefore, negative vertical velocity will only stop the particle from rising temporarily,
while a positive vertical velocity will make the particle rise immediately.
:::

### List of rising particles
<details>
  <summary>Show list</summary>
  - EFFECT
  - ENTITY_EFFECT
  - GLOW
  - INFESTED
  - INSTANT_EFFECT
  - RAID_OMEN
  - TRIAL_OMEN
  - WITCH
</details>

## Scalable particles
These particles can be scaled with `offsetX`, while `offsetY` and `offsetZ` are ignored. This chapter does not include dust particles,
those particles are covered in [Dust particles](#dust-particles) and [Dust transition particles](#dust-transition-particles) chapters.

:::note
If the final calculated scale is negative, the particle will appear mirrored.
:::

### Sweep attack particles
The `SWEEP_ATTACK` particle's scale is calculated as `1.0 - offsetX * 0.5`.

An example where two sweep attack particles will spawn at `someLocation`. First one with a scale of `1.0` and the second
one with a scale of `2.0` right after:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    ParticleBuilder sweepAttackParticleBuilder = Particle.SWEEP_ATTACK.builder()
      .location(someLocation)
      .count(0)
      .receivers(32, true)
      .spawn();

    Bukkit.getScheduler().runTaskLater(plugin,
      () -> sweepAttackParticleBuilder.offset(-2.0, 0, 0).spawn(), 10);
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.SWEEP_ATTACK, someLocation, 0);

    Bukkit.getScheduler().runTaskLater(plugin,
      () -> someWorld.spawnParticle(Particle.SWEEP_ATTACK, someLocation, 0, -2.0, 0, 0), 10);
    ```
  </TabItem>
</Tabs>

![Sweep attack particle scale comparison](./assets/particles/sweep-attack.webp)

### Explosion particles
The `EXPLOSION` particle's scale is calculated as `2.0 * (1.0 - offsetX * 0.5)`.

An example where two explosion particles will spawn at `someLocation`. First one with a scale of `1.0` and the second
one with a scale of `4.0` right after:
<Tabs syncKey="spawn-type">
  <TabItem label="ParticleBuilder">
    ```java
    ParticleBuilder explosionParticleBuilder = Particle.EXPLOSION.builder()
      .location(someLocation)
      .offset(1, 0, 0)
      .count(0)
      .receivers(32, true)
      .spawn();

    Bukkit.getScheduler().runTaskLater(plugin,
      () -> explosionParticleBuilder.offset(-2.0, 0, 0).spawn(), 10);
    ```
  </TabItem>
  <TabItem label="spawnParticle">
    ```java
    someWorld.spawnParticle(Particle.EXPLOSION, someLocation, 0, 1, 0, 0);

    Bukkit.getScheduler().runTaskLater(plugin,
      () -> someWorld.spawnParticle(Particle.EXPLOSION, someLocation, 0, -2.0, 0, 0), 10);
    ```
  </TabItem>
</Tabs>

![Explosion particle scale comparison](./assets/particles/explosion.webp)

## Miscellaneous behaviors
This chapter covers particles that have unique behaviors when spawning.

### Angry villager particles
The `ANGRY_VILLAGER` particle always spawns `0.5` higher (y-axis) than the supplied location.

### Cloud particles
The `CLOUD` and `SNEEZE` particles move towards the player's y level, if they are within two blocks distance from the player's
location. When they reach the player's y level, their vertical velocity will be greatly reduced.

If the player is moving vertically, the particles will attempt to match the player's vertical velocity.

### Splash particles
The `SPLASH` particle uses the `offsetX` and `offsetZ` arguments to determine the particle's velocity vector, if two conditions are met:
1. `offsetY` is `0`
2. Either `offsetX` or `offsetZ` are not `0`

### Damage indicator particles
The `DAMAGE_INDICATOR` particle adds `1.0` to the provided `offsetY`.

### Dust pillar particles
The `DUST_PILLAR` particle uses `offsetY` for the y-axis velocity, while `offsetX` and `offsetZ` are ignored.

### Dust plume particles
The `DUST_PLUME` particle adds `0.15` to the provided `offsetY`.

### Firefly particles
The `FIREFLY` particle uses `offsetY` as the particle's initial y-axis velocity, however, there is 50% chance for the `offsetY`'s
sign to be inverted. This means that the particle will either move up or down, with equal probability.
